% Generate polynomial dynamics using symbolic toolbox
function [dydt, Y, U] = Gen_Dyn_helper( contactB, contactF )

% Define model parameters:
    k  = 20;
    la = 0.5; % distance from CG to hip
    l = 1;  % original leg length
    ks = 5; % omega = sqrt(5);
    M = 1;
    J = 1.04625;%1.5;%1.046875;% 0.3; % 0.25;
    g = 1; % gravity

    Y = sym('Y',[10,1],'real');
    U = sym('u',[2,1],'real');
    dydt = ode( [], Y );

%**********************************************************************
% Dynamics Function
%**********************************************************************
    function dydt_ = ode(~,Y)
 % Extract individual states:
        x       = Y(1);
        dx      = Y(2);
        y       = Y(3);
        dy      = Y(4);
        phi     = Y(5);
        dphi    = Y(6);
        alphaB  = Y(7);
        dalphaB = Y(8);
        alphaF  = Y(9);
        dalphaF = Y(10);

        uB = U(1);
        uF = U(2);

        pos0 = [x;y];
        posF = pos0 + la*[cos(phi);sin(phi)] ;              % front hip
        posB = pos0 + la*[cos(phi + pi);sin(phi + pi)] ;    % back hip

        % Compute forces acting on the main body (only legs in contact
        % contribute):

        Bforce = 0;
        Fforce = 0;

        if contactB
            lB = posB(2)/cos(alphaB+phi);
            Bforce = (l+uB-lB)*k;
        end
        if contactF
            lF = posF(2)/cos(alphaF+phi);
            Fforce = (l+uF-lF)*k;
        end

        Fx  = -Bforce*sin(alphaB+phi) - Fforce*sin(alphaF+phi);
        Fy  =  Bforce*cos(alphaB+phi) + Fforce*cos(alphaF+phi);
        Tor = -Bforce*la*cos(alphaB)  + Fforce*la*cos(alphaF);

        % Compute main body acceleration:
        ddx   = Fx / M;
        ddy   = ( Fy - g ) / M;
        ddphi = Tor / J;


        Asv = [x y phi alphaB alphaF dx dy dphi dalphaB dalphaF ddx ddy ddphi 0 0]';
        % Compute leg acceleration:

        if contactB
            [dalphaB,ddalphaB] = Func_alphaB_VA(Asv);

        else

            ddalphaB = - ( Tor/J - Tor*la*sin(alphaB)/(J*l) ...
                         + Fx*cos(alphaB + phi)/(M*l)...
                         + Fy*sin(alphaB + phi)/(M*l)...
                         + alphaB*ks/(l^2)...
                         + dphi^2*la*cos(alphaB)/l);
        end

        if contactF
            [dalphaF,ddalphaF] = Func_alphaF_VA(Asv);
        else
            ddalphaF = - ( Tor/J + Tor*la*sin(alphaF)/(J*l)...
                         + Fx*cos(alphaF + phi)/(M*l)...
                         + Fy*sin(alphaF + phi)/(M*l)...
                         + alphaF*ks/(l^2)...
                         - dphi^2*la*cos(alphaF)/l);
        end

        dydt_ = [dx;ddx;dy;ddy;dphi;ddphi;dalphaB;ddalphaB;dalphaF;ddalphaF];

    end
    function [dalphaB_,ddalphaB_] = Func_alphaB_VA(in1)
    %FUNC_ALPHAB_VA
    %    [DALPHAB,DDALPHAB] = FUNC_ALPHAB_VA(IN1)

    %    This function was generated by the Symbolic Math Toolbox version 8.0.
    %    28-Nov-2017 11:29:14

    alphaB_ = in1(4,:);
    % dalphaB_ = in1(9,:);
    ddphi_ = in1(13,:);
    ddx_ = in1(11,:);
    ddy_ = in1(12,:);
    dphi_ = in1(8,:);
    dx_ = in1(6,:);
    dy_ = in1(7,:);
    phi_ = in1(3,:);
    y_ = in1(2,:);
    t2 = alphaB_.*2.0;
    t3 = phi_.*2.0;
    t4 = t2+t3;
    t5 = sin(phi_);
    dalphaB_ = (dx_-dphi_.*t5.*(1.0./2.0)+dphi_.*y_.*2.0-dphi_.*sin(phi_+t2).*(1.0./2.0)+dx_.*cos(t4)+dy_.*sin(t4))./(t5-y_.*2.0);
    if nargout > 1
        t6 = alphaB_+t3;
        t7 = cos(t6);
        t8 = alphaB_.*3.0;
        t9 = phi_.*3.0;
        t10 = t8+t9;
        t11 = alphaB_+phi_;
        t12 = cos(t11);
        t13 = dphi_.^2;
        t14 = t3+t8;
        t15 = sin(t6);
        t16 = dalphaB_.^2;
        t17 = cos(alphaB_);
        t18 = sin(t11);
        ddalphaB_ = -(-ddphi_.*t15+ddx_.*t12.*6.0+ddy_.*t18.*2.0+t7.*t13+t7.*t16.*4.0-t13.*t17.*6.0-t16.*t17.*4.0+ddx_.*cos(t10).*2.0+t13.*cos(t14)-ddphi_.*sin(t14)+ddy_.*sin(t10).*2.0+dalphaB_.*dphi_.*t7.*4.0-dalphaB_.*dphi_.*t17.*1.2e1+dalphaB_.*dy_.*t12.*1.6e1+dphi_.*dy_.*t12.*1.6e1+ddphi_.*t12.*y_.*8.0+t13.*t18.*y_.*1.6e1+t16.*t18.*y_.*1.6e1+dalphaB_.*dphi_.*t18.*y_.*3.2e1)./(t15.*-2.0+sin(alphaB_).*2.0+t12.*y_.*8.0);
    end
    end
    function [dalphaF_,ddalphaF_] = Func_alphaF_VA(in1)
    %FUNC_ALPHAF_VA
    %    [DALPHAF,DDALPHAF] = FUNC_ALPHAF_VA(IN1)

    %    This function was generated by the Symbolic Math Toolbox version 8.0.
    %    28-Nov-2017 11:29:12

    alphaF_ = in1(5,:);
    % dalphaF_ = in1(10,:);
    ddphi_ = in1(13,:);
    ddx_ = in1(11,:);
    ddy_ = in1(12,:);
    dphi_ = in1(8,:);
    dx_ = in1(6,:);
    dy_ = in1(7,:);
    phi_ = in1(3,:);
    y_ = in1(2,:);
    t2 = alphaF_.*2.0;
    t3 = phi_.*2.0;
    t4 = t2+t3;
    t5 = sin(phi_);
    dalphaF_ = -(dx_+dphi_.*t5.*(1.0./2.0)+dphi_.*y_.*2.0+dphi_.*sin(phi_+t2).*(1.0./2.0)+dx_.*cos(t4)+dy_.*sin(t4))./(t5+y_.*2.0);
    if nargout > 1
        t6 = alphaF_+t3;
        t7 = cos(t6);
        t8 = alphaF_.*3.0;
        t9 = phi_.*3.0;
        t10 = t8+t9;
        t11 = alphaF_+phi_;
        t12 = cos(t11);
        t13 = dphi_.^2;
        t14 = t3+t8;
        t15 = sin(t6);
        t16 = dalphaF_.^2;
        t17 = cos(alphaF_);
        t18 = sin(t11);
        ddalphaF_ = -(ddphi_.*t15+ddx_.*t12.*6.0+ddy_.*t18.*2.0-t7.*t13-t7.*t16.*4.0+t13.*t17.*6.0+t16.*t17.*4.0+ddx_.*cos(t10).*2.0-t13.*cos(t14)+ddphi_.*sin(t14)+ddy_.*sin(t10).*2.0-dalphaF_.*dphi_.*t7.*4.0+dalphaF_.*dphi_.*t17.*1.2e1+dalphaF_.*dy_.*t12.*1.6e1+dphi_.*dy_.*t12.*1.6e1+ddphi_.*t12.*y_.*8.0+t13.*t18.*y_.*1.6e1+t16.*t18.*y_.*1.6e1+dalphaF_.*dphi_.*t18.*y_.*3.2e1)./(t15.*2.0-sin(alphaF_).*2.0+t12.*y_.*8.0);
    end
    end

end
